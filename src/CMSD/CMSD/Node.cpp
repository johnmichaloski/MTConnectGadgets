////////////////////////////////////////////////////////////////////////
//
// Node.cpp
//
// This file was generated by XMLSpy 2011r3sp1 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "../Altova/Altova.h"
#include "../Altova/AltovaException.h"

#include "XmlException.h"
#include "Node.h"
#include <vector>


//#import "msxml6.dll" implementation_only rename_namespace("NewName")
#import <msxml6.dll>



#pragma warning(disable:4996)	// VS2005 deprecation

void MsxmlTreeOperations::CopyAll(const MSXML2::IXMLDOMNodePtr src, MSXML2::IXMLDOMNodePtr tgt)
{
	// nodes
	for (MSXML2::IXMLDOMNodePtr node = src->firstChild; node != 0; node = node->nextSibling)
		tgt->appendChild(node->cloneNode(VARIANT_TRUE));
	// attributes
	MSXML2::IXMLDOMNamedNodeMapPtr attrz = src->attributes;
	for (int i = 0; i < attrz->length; i++)
		((MSXML2::IXMLDOMElementPtr)tgt)->setAttributeNode((MSXML2::IXMLDOMAttributePtr)attrz->item[i]->cloneNode(VARIANT_TRUE));
} 

bool MsxmlTreeOperations::IsEqualString(const char_type* a, const char_type* b)
{
	if (a == b) return true;
	if (a == 0) a = _T("");
	if (b == 0) b = _T("");
	return _tcscmp(a, b) == 0;
}


bool MsxmlTreeOperations::IsMember( const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMember )
{
	if (*pMember->LocalName == 0)
		return pNode->nodeType == MSXML2::NODE_TEXT ||
			pNode->nodeType == MSXML2::NODE_CDATA_SECTION;

	if (pNode->nodeType != MSXML2::NODE_ELEMENT)
		return false;

	return IsEqualString(pNode->baseName, pMember->LocalName) &&
		IsEqualString(pNode->namespaceURI, pMember->NamespaceURI);			
}


bool MsxmlTreeOperations::IsValid(const MSXML2::IXMLDOMNodePtr& pNode) 
{ 
	return pNode != 0; 
}

MsxmlTreeOperations::AllIterator MsxmlTreeOperations::GetElements(const MSXML2::IXMLDOMNodePtr& pNode)
{
	return AllIterator(pNode->firstChild);
}

MsxmlTreeOperations::MemberIterator MsxmlTreeOperations::GetElements(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo)
{
	return MemberIterator(pNode->firstChild, pMemberInfo);
}

void MsxmlTreeOperations::SetTextValue(const MSXML2::IXMLDOMNodePtr& pNode, const string_type& sText)
{
	pNode->text = sText.c_str();
}

string_type MsxmlTreeOperations::GetTextValue(const MSXML2::IXMLDOMNodePtr& pNode)
{
	return (const char_type*) pNode->text;
}

static void FindDeclarationsForNamespace(const MSXML2::IXMLDOMNodePtr& pNode, const _bstr_t& uri, std::vector<MSXML2::IXMLDOMNodePtr>& declarations)
{
	if (pNode->parentNode != 0)
		FindDeclarationsForNamespace(pNode->parentNode, uri, declarations);

	MSXML2::IXMLDOMNamedNodeMapPtr attrs = pNode->attributes;
	if (attrs == 0)
		return;

	attrs->reset();
	for (MSXML2::IXMLDOMNodePtr att = attrs->nextNode(); att != 0; att = attrs->nextNode())
	{
		// note: in MSXML the default ns can be an attribute with prefix "xmlns" and empty baseName - ignore this
		if (att->prefix == _bstr_t(_T("xmlns")) && att->baseName != _bstr_t(_T("")))
		{
			if (_bstr_t(att->nodeValue) == uri)
			{
				declarations.push_back(att);								
			}
			else 
			{
				for (std::vector<MSXML2::IXMLDOMNodePtr>::iterator it = declarations.begin(); it != declarations.end(); )
				{
					MSXML2::IXMLDOMNodePtr cur = *it;
					if (cur->baseName == att->baseName)					
						declarations.erase(it);
					else
						++it;
				}
			}
		}
	}
}

_bstr_t FindPrefixForNamespace(const MSXML2::IXMLDOMNodePtr& node, const _bstr_t& uri)
{
	if (uri == _bstr_t(_T("http://www.w3.org/XML/1998/namespace")))
		return _bstr_t(_T("xml"));
		
	if (uri == _bstr_t(_T("http://www.w3.org/2000/xmlns/")))
		return _bstr_t(_T("xmlns"));

	_bstr_t prefix;

	std::vector<MSXML2::IXMLDOMNodePtr> declarations;
	FindDeclarationsForNamespace(node, uri, declarations);
	if (!declarations.empty())
		prefix = declarations.front()->baseName;
	else
		prefix = _bstr_t(_T(""));
	return prefix;
}


static _bstr_t GetUnusedPrefixForNode(const MSXML2::IXMLDOMNodePtr& node, const string_type& uri, int n, const string_type& prefixHint = _T(""))
{
	string_type pp = _T("n");
	if (!prefixHint.empty())
		pp = prefixHint;

	bool first = true;
	
	while (true)
	{
		char_type buf[30];

		if ( first && uri == _T("http://www.w3.org/2001/XMLSchema") )
			_tcscpy(buf, _T("xs"));
		else
		if ( first && uri == _T("http://www.w3.org/2001/XMLSchema-instance") )
			_tcscpy(buf, _T("xsi"));
		else
		{
			n++;
			if (n > 0 || prefixHint.empty())
			{	
				pp += _T("%u");
				_sntprintf(buf, 30, pp.c_str() , n);
			}
			else
				_tcscpy(buf, pp.c_str());
		}
		
		if (node->nodeType != MSXML2::NODE_ELEMENT)
			return _bstr_t(buf);

		first = false;

		bstr_t ns = _bstr_t(_T("xmlns:")) + _bstr_t(buf);
		if (node->attributes->getNamedItem(ns) != 0)
			continue;

		if (node->parentNode != 0)
			return GetUnusedPrefixForNode(node->parentNode, uri, n-1, prefixHint);
		else
			return _bstr_t(_T(""));
	}
}

static _bstr_t FindUnusedPrefix(const MSXML2::IXMLDOMNodePtr& node, const string_type& uri, const string_type& prefixHint = _T(""))
{
	return GetUnusedPrefixForNode(node, uri, -1, prefixHint);
}

_bstr_t GetUnusedPrefix(const MSXML2::IXMLDOMNodePtr& node, const string_type& uri, const string_type& prefixHint)
{
	return FindUnusedPrefix(node, uri, prefixHint);
}

static _bstr_t FindNamespaceUriForPrefix(const MSXML2::IXMLDOMNodePtr& pNode, const _bstr_t& prefix)
{
	if (pNode->nodeType != MSXML2::NODE_ELEMENT)
		return _bstr_t(_T(""));

	_bstr_t ns = _bstr_t(_T("xmlns:")) + prefix;

	MSXML2::IXMLDOMNodePtr item = pNode->attributes->getNamedItem(ns);

	if (item)
		return item->text;

	if (pNode->parentNode != 0)
		return FindNamespaceUriForPrefix(pNode->parentNode, prefix);
		
	return _bstr_t(_T(""));
}

void MsxmlTreeOperations::SetValue(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo, const _bstr_t& bValue)
{
	if (*pMemberInfo->LocalName != 0)
	{		
		_bstr_t prefix;
		if (*pMemberInfo->NamespaceURI)
		{
			prefix = FindPrefixForNamespace(pNode, pMemberInfo->NamespaceURI);
			if (prefix == _bstr_t(_T("")))
				prefix = FindUnusedPrefix(pNode, pMemberInfo->NamespaceURI) + _bstr_t(_T(":"));
			else
				prefix += _bstr_t(_T(":"));
		}

		// no namespace declaration required
		MSXML2::IXMLDOMNodePtr pAttr = pNode->ownerDocument->createNode(_variant_t((short)MSXML2::NODE_ATTRIBUTE), prefix + _bstr_t(pMemberInfo->LocalName), _bstr_t(pMemberInfo->NamespaceURI));
		pAttr->text = bValue;
		pNode->attributes->setNamedItem(pAttr);
	}
	else
	{
		pNode->text = bValue;
	}			
}

void MsxmlTreeOperations::SetValue(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo, const altova::QName& qn)
{
	if (qn.Uri.empty())
	{
		SetValue(pNode, pMemberInfo, _bstr_t(qn.LocalName.c_str()));
		return;
	}

	_bstr_t prefix = FindPrefixForNamespace(pNode, _bstr_t(qn.Uri.c_str()));
	if (prefix.length() == 0)
	{
		prefix = FindUnusedPrefix(pNode, qn.Uri, qn.Prefix);
		MSXML2::IXMLDOMElementPtr el = pNode;
		el->setAttribute(_bstr_t(_T("xmlns:")) + prefix, _bstr_t(qn.Uri.c_str()));
	}
	
	SetValue(pNode, pMemberInfo, prefix + _bstr_t(_T(":")) + _bstr_t(qn.LocalName.c_str()));
}

inline altova::XmlFormatter* GetFormatter(const altova::MemberInfo* pMember)
{
	if (((pMember->Binder->Types + pMember->DataType)->Formatter))
		return static_cast<altova::XmlFormatter*>(*((pMember->Binder->Types + pMember->DataType)->Formatter));
	else
		return static_cast<altova::XmlFormatter*>(altova::AnySimpleTypeFormatter);
}



void MsxmlTreeOperations::SetValue(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo, const string_type& sValue)
{
	SetValue(pNode, pMemberInfo, _bstr_t(sValue.c_str()));
}

void MsxmlTreeOperations::SetValue(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo, bool b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format(b));
}

void MsxmlTreeOperations::SetValue(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo, int b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format((__int64)b));
}

void MsxmlTreeOperations::SetValue(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo, unsigned b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format((unsigned __int64)b));
}

void MsxmlTreeOperations::SetValue(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo, __int64 b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format(b));
}

void MsxmlTreeOperations::SetValue(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo, unsigned __int64 b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format(b));
}

void MsxmlTreeOperations::SetValue(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo, double b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format(b));
}

void MsxmlTreeOperations::SetValue(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo, altova::DateTime b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format(b));
}

void MsxmlTreeOperations::SetValue(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo, altova::Duration b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format(b));
}

void MsxmlTreeOperations::SetValue(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo, const std::vector<unsigned char>& b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format(b));
}


void MsxmlTreeOperations::SetValue(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo, const MSXML2::IXMLDOMNodePtr& b)
{
	SetValue(pNode, pMemberInfo, b->text);
}


MSXML2::IXMLDOMNodePtr MsxmlTreeOperations::AddElement(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo)
{
	_bstr_t prefix;
	if (*pMemberInfo->NamespaceURI)
	{
		prefix = FindPrefixForNamespace(pNode, pMemberInfo->NamespaceURI);
		if (prefix != _bstr_t(_T("")))
			prefix += _bstr_t(_T(":"));
	}

	MSXML2::IXMLDOMDocumentPtr pDoc = pNode->ownerDocument;
	if (pDoc == 0)
		pDoc = pNode;
	MSXML2::IXMLDOMNodePtr pNewNode = pDoc->createNode(_variant_t((short)MSXML2::NODE_ELEMENT), 
		prefix + _bstr_t(pMemberInfo->LocalName), _bstr_t(pMemberInfo->NamespaceURI));
	pNode->appendChild(pNewNode);
	return pNewNode;
}

double MsxmlTreeOperations::CastToDouble(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo)
{
	return altova::CoreTypes::CastToDouble(string_type(pNode->text));
}


string_type MsxmlTreeOperations::CastToString(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo)
{
	return altova::CoreTypes::CastToString(string_type(pNode->text));
}


__int64 MsxmlTreeOperations::CastToInt64(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo)
{
	return altova::CoreTypes::CastToInt64(string_type(pNode->text));
}

unsigned __int64 MsxmlTreeOperations::CastToUInt64(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo)
{
	return altova::CoreTypes::CastToUInt64(string_type(pNode->text));
}

unsigned MsxmlTreeOperations::CastToUInt(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo)
{
	return altova::CoreTypes::CastToUInt(string_type(pNode->text));
}

int MsxmlTreeOperations::CastToInt(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo)
{
	return altova::CoreTypes::CastToInt(string_type(pNode->text));
}


bool MsxmlTreeOperations::CastToBool(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo)
{
	if (pNode->text == _bstr_t(_T("false")) || pNode->text == _bstr_t(_T("0")))
		return false;
	return true;
}

altova::DateTime MsxmlTreeOperations::CastToDateTime(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo)
{
	return altova::CoreTypes::CastToDateTime(string_type(pNode->text));
}

altova::Duration MsxmlTreeOperations::CastToDuration(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo)
{
	return altova::CoreTypes::CastToDuration(string_type(pNode->text));
}

std::vector<unsigned char> MsxmlTreeOperations::CastToBinary(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemberInfo)
{
	return GetFormatter(pMemberInfo)->ParseBinary(string_type(pNode->text));
}

altova::QName MsxmlTreeOperations::CastToQName(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* pMemmberInfo )
{
	string_type value(pNode->text);
	size_t i =  value.find(_T(':'));
	if (i == string_type::npos)
		return altova::CoreTypes::CastToQName(value);
	
	string_type prefix = value.substr(0, i);
	string_type local = value.substr(i+1);

	string_type uri = FindNamespaceUriForPrefix(pNode, _bstr_t(prefix.c_str()));
	
	return altova::QName(uri, prefix, local);
}

MSXML2::IXMLDOMNodePtr MsxmlTreeOperations::FindAttribute(
	const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* member)
{
	MSXML2::IXMLDOMElementPtr pEl( pNode );
	MSXML2::IXMLDOMNamedNodeMapPtr attributes = pEl->attributes;
	return attributes->getQualifiedItem( _bstr_t(member->LocalName), _bstr_t(member->NamespaceURI) );
}

MSXML2::IXMLDOMNodePtr MsxmlTreeOperations::GetParent(const MSXML2::IXMLDOMNodePtr& pNode)
{
	return pNode->parentNode;
}


void MsxmlTreeOperations::SetValue(const MSXML2::IXMLDOMNodePtr& pNode, const string_type& sValue)
{
	pNode->nodeValue = _bstr_t(sValue.c_str());
}

void MsxmlTreeOperations::RemoveAttribute(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* member)
{
	if (*member->LocalName)
	{
		if (pNode->attributes != 0)
			pNode->attributes->removeQualifiedItem(member->LocalName, member->NamespaceURI);
	}
	else
	{
		for (MSXML2::IXMLDOMNodePtr pChild = pNode->firstChild; pChild; )
		{
			MSXML2::IXMLDOMNodePtr cur = pChild;
			pChild = pChild->nextSibling;
			if (cur->nodeType == short(MSXML2::NODE_TEXT) ||
				cur->nodeType == short(MSXML2::NODE_CDATA_SECTION))
			{
				pNode->removeChild(cur);
			}			
		}
	}
}

void MsxmlTreeOperations::RemoveElements(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* member)
{
	for (MSXML2::IXMLDOMNodePtr pChild = pNode->firstChild; pChild; )
	{
		MSXML2::IXMLDOMNodePtr cur = pChild;
		pChild = pChild->nextSibling;
		if (IsMember(cur, member))
			pNode->removeChild(cur);
	}
}

void MsxmlTreeOperations::RemoveElement(const MSXML2::IXMLDOMNodePtr& pNode, const altova::MemberInfo* member, unsigned index)
{
	for (MSXML2::IXMLDOMNodePtr pChild = pNode->firstChild; pChild; )
	{
		MSXML2::IXMLDOMNodePtr cur = pChild;
		pChild = pChild->nextSibling;
		if (IsMember(cur, member) && index-- == 0)
		{
			pNode->removeChild(cur);
			break;
		}
	}
}




MsxmlTreeOperations::DocumentType MsxmlTreeOperations::LoadDocument(const string_type& filename)
{
	try {
		MSXML2::IXMLDOMDocumentPtr result = MsxmlTreeOperations::CreateDocument();
		
		result->load(filename.c_str());
		MSXML2::IXMLDOMParseErrorPtr error = result->parseError;
		if (error->errorCode != 0)
		{
			throw altova::DataSourceUnavailableException(filename + _T(": Parse error while loading: ") + (TCHAR*) error->reason);
		}
		return result;
	} 
	catch (_com_error& error)
	{
		throw altova::DataSourceUnavailableException(filename + _T(": COM error while loading: ") + error.ErrorMessage());
	}	
}

void MsxmlTreeOperations::FreeDocument(DocumentType& document)
{
	document.Release();
}

void MsxmlTreeOperations::FreeDocument(MSXML2::IXMLDOMNodePtr& document)
{
	document.Release();
}

static void Format(const MSXML2::IXMLDOMDocumentPtr& doc, const MSXML2::IXMLDOMNodePtr& node, unsigned indent)
{
	for (MSXML2::IXMLDOMNodePtr child = node->firstChild; child != 0; child = child->nextSibling)
	{
		short nodeType = child->nodeType;
		if (nodeType == MSXML2::NODE_TEXT ||
			nodeType == MSXML2::NODE_CDATA_SECTION)
		{
			return;	// stop insertion of line breaks, this is mixed content.
		}

		// insert a line break before the node, unless it is the XML declaration.
		if (nodeType == MSXML2::NODE_PROCESSING_INSTRUCTION && child->nodeName == _bstr_t(_T("xml")))
			continue;

		string_type text(indent, _T('\t'));
		text = _T("\r\n") + text;
		if (node->nodeType == MSXML2::NODE_ELEMENT)
			node->insertBefore(doc->createTextNode(text.c_str()), _variant_t(child.GetInterfacePtr()));

		if (nodeType == MSXML2::NODE_ELEMENT)
		{
			Format(doc, child, indent + 1);
		}
	}
	if (node->nodeType == MSXML2::NODE_ELEMENT && node->hasChildNodes())
	{
		string_type text(indent - 1, _T('\t'));
		text = _T("\r\n") + text;
		node->appendChild(doc->createTextNode(text.c_str()));
	}
}

static bool IsXmlDeclaration(const MSXML2::IXMLDOMNodePtr& node)
{
	if (node == NULL)
		return false;
		
	if (node->nodeType != MSXML2::NODE_PROCESSING_INSTRUCTION)
		return false;

	return (node->nodeName == _bstr_t(L"xml"));		
}

void MsxmlTreeOperations::SaveDocument( const DocumentType& document, const string_type& filename, bool prettyPrint )
{
	SaveDocument( document, filename, prettyPrint, _T("UTF-8"), false, false );
}

void MsxmlTreeOperations::SaveDocument( const DocumentType& document, const string_type& filename, bool prettyPrint, const string_type& encoding, bool bBigEndian, bool bBOM )
{
	std::vector<unsigned char> bytes;
	SaveToBinary( bytes, document, prettyPrint, encoding, bBigEndian, bBOM );

	FILE *f = _tfopen( filename.c_str(), _T("wb") );
	if( !f )
		throw altova::DataTargetUnavailableException( _T("Could not open file ") + filename + _T(" for writing.") );

	fwrite( &bytes[0], bytes.size(), 1, f );
	fclose( f );
}

MsxmlTreeOperations::DocumentType MsxmlTreeOperations::LoadXml(const string_type& xml)
{
	try 
	{
		MSXML2::IXMLDOMDocumentPtr result = MsxmlTreeOperations::CreateDocument();
		
		result->loadXML(xml.c_str());
		MSXML2::IXMLDOMParseErrorPtr error = result->parseError;
		if (error->errorCode != 0)
		{
			throw altova::DataSourceUnavailableException(string_type(_T("Parse error while loading: ")) + (TCHAR*) error->reason);
		}
		return result;	
	}
	catch (_com_error& error)
	{
		throw altova::DataSourceUnavailableException(string_type(_T("COM error while loading: ")) + error.ErrorMessage());
	}
}

string_type MsxmlTreeOperations::SaveXml(const DocumentType& document, bool prettyPrint)
{
	try 
	{
		// MSXML cannot pretty print itself
		if (prettyPrint)
		{
			DocumentType docClone = CreateDocument();
			document->save(docClone.GetInterfacePtr());

			// now format
			MSXML2::IXMLDOMNodePtr node = docClone;

			docClone->preserveWhiteSpace = VARIANT_FALSE;
			Format(docClone, node, 0);

			return (const char_type*)docClone->xml;
		}
		else
		{
			return (const char_type*)document->xml;
		}
	}
	catch (_com_error& error)
	{
		throw altova::DataTargetUnavailableException(string_type(_T("COM error while saving: ")) + error.ErrorMessage());
	}
}

MsxmlTreeOperations::DocumentType MsxmlTreeOperations::CreateDocument()
{
	try 
	{
		MSXML2::IXMLDOMDocument2Ptr ptr;
		ptr.CreateInstance(__uuidof(MSXML2::DOMDocument60));
		ptr->setProperty(L"ProhibitDTD", false);
		ptr->setProperty(L"ValidateOnParse", false);
		ptr->preserveWhiteSpace = VARIANT_TRUE;
		
		return ptr;
	}
	catch (_com_error& error)
	{
		throw altova::DataTargetUnavailableException(string_type(_T("COM error while creating: ")) + error.ErrorMessage());
	}
}

void MsxmlTreeOperations::AddProcessingInstruction(const MSXML2::IXMLDOMNodePtr& node, const string_type& target, const string_type& value)
{
	MSXML2::IXMLDOMDocumentPtr doc = node->ownerDocument;
	if (doc == 0)
		doc = node;
	node->appendChild(doc->createProcessingInstruction(target.c_str(), value.c_str()));
}

MsxmlTreeOperations::DocumentType MsxmlTreeOperations::LoadFromBinary(const std::vector<unsigned char>& binary)
{
	try 
	{
		MSXML2::IXMLDOMDocument2Ptr spDocument;

		if ( binary.empty() )
		{
			return spDocument;
		}

		_variant_t x;
		x.vt = VT_ARRAY|VT_UI1;
		size_t nSize = binary.size();
		x.parray = SafeArrayCreateVector( VT_UI1, 0, (ULONG) nSize );

		void* pDest;
		SafeArrayAccessData( x.parray, &pDest );
		memcpy( pDest, &binary.front(), nSize );
		SafeArrayUnaccessData( x.parray );     

		spDocument = MsxmlTreeOperations::CreateDocument();
		spDocument->load(x);

		MSXML2::IXMLDOMParseErrorPtr error = spDocument->parseError;
		if (error->errorCode != 0)
		{
			throw altova::DataSourceUnavailableException(string_type(_T("Parse error while loading: ")) + (TCHAR*) error->reason);
		}
		return spDocument;
	}
	catch (_com_error& error)
	{
		throw altova::DataSourceUnavailableException(string_type(_T("COM error while loading: ")) + error.ErrorMessage());
	}
}

std::vector<unsigned char> MsxmlTreeOperations::SaveToBinary(const DocumentType& document, bool prettyPrint)
{
	std::vector<unsigned char> result;
	SaveToBinary( result, document, prettyPrint, _T(""), false, false, false );
	return result;
}

void MsxmlTreeOperations::SaveToBinary( std::vector<unsigned char>& result, const DocumentType& document, bool prettyPrint, const string_type& encoding, bool bBigEndian, bool bBOM, bool bIncludeEncoding )
{
	try
	{
		string_type xmldeclcontent = _T("version=\"1.0\" encoding=\"") + encoding + _T("\"");

		DocumentType doc_to_write = document;
		MSXML2::IXMLDOMNodePtr xmlpi;
		MSXML2::IXMLDOMNodePtr old;
		bool bResetProcessingInstruction = false;

		// MSXML cannot pretty print itself
		if (prettyPrint)
		{
			DocumentType docClone = CreateDocument();
			document->save(docClone.GetInterfacePtr());
			
			// insert/replace xml declaration
			if( bIncludeEncoding )
			{
				xmlpi = docClone->createProcessingInstruction(L"xml", xmldeclcontent.c_str());
				if (IsXmlDeclaration(docClone->firstChild))
					docClone->replaceChild(xmlpi, docClone->firstChild);
				else
					docClone->insertBefore(xmlpi, docClone->firstChild.GetInterfacePtr());
			}

			// now format
			MSXML2::IXMLDOMNodePtr node = docClone;
			docClone->preserveWhiteSpace = VARIANT_FALSE;
			Format(docClone, node, 0);			

			doc_to_write = docClone;
		}
		else
		{
			if( bIncludeEncoding )
			{
				xmlpi = document->createProcessingInstruction(L"xml", xmldeclcontent.c_str());
				if (IsXmlDeclaration(document->firstChild))
					old = document->replaceChild(xmlpi, document->firstChild);
				else
					document->insertBefore(xmlpi, document->firstChild.GetInterfacePtr());

				bResetProcessingInstruction = true;
			}
		}

		IStream* stream = 0;
		CreateStreamOnHGlobal(NULL, TRUE, &stream);
		doc_to_write->save(stream);
		HGLOBAL global;
		LARGE_INTEGER li = { 0 };
		ULARGE_INTEGER ul;
		stream->Seek(li, STREAM_SEEK_END, &ul);
		GetHGlobalFromStream(stream, &global);
		unsigned char* ptr = (unsigned char*) GlobalLock(global);
		result.clear();
		result.insert(result.end(), ptr, ptr + ul.QuadPart);
		GlobalUnlock(global);
		stream->Release();

		if( bIncludeEncoding )
			CorrectByteOrderAndBOM( result, encoding, bBigEndian, bBOM );

		if( bResetProcessingInstruction )
		{
			if (old)
				document->replaceChild(old, xmlpi);
			else
				document->removeChild(xmlpi);
		}
	}
	catch (_com_error& error)
	{
		throw altova::DataTargetUnavailableException(string_type(_T("COM error while saving: ")) + error.ErrorMessage());
	}
}

void MsxmlTreeOperations::CorrectByteOrderAndBOM( std::vector<unsigned char>& bytes, const string_type& encoding, bool bBigEndian, bool bBOM )
{
	if( bytes.size() == 0 || encoding.empty() )
		return;

	int unisize = GetUnicodeSizeFromEncodingName( encoding );
	if( unisize == 0 )
		return;

	if( unisize < 2 )
		bBigEndian = false;

	int encbo = GetEncodingAndByteOrderFromXml( bytes );

	bool bHasBOM = (encbo & 0x10) != 0;
	bool bIsBigEndian = (encbo & 0x20) != 0;

	if( bBOM == bHasBOM && bBigEndian == bIsBigEndian )
		return;

	int off = 0;
	int len = (int) bytes.size();

	if( unisize > 0 && bBOM && !bHasBOM )
	{
		if( unisize == 1 )
		{
			bytes.insert( bytes.begin(), 3, 0 );
			bytes[0] = 0xef;
			bytes[1] = 0xbb;
			bytes[2] = 0xbf;
			off = 3;
		}
		else
		if( unisize == 2 )
		{
			if( bBigEndian ) {
				bytes.insert( bytes.begin(), 2, 0 );
				bytes[0] = 0xfe;
				bytes[1] = 0xff;
				off = 2;
			} else {
				bytes.insert( bytes.begin(), 2, 0 );
				bytes[0] = 0xff;
				bytes[1] = 0xfe;
				off = 2;
			}
		}
	}

	if( !bBOM && bHasBOM )
	{
		int bomsize = (encbo & 0xf00) >> 8;
		off += bomsize;
		len -= bomsize;
	}

	if( bBigEndian != bIsBigEndian && unisize >= 2 )
	{
		unsigned char* ptr = &bytes[0];
		ptr += off;
		int count = (len / unisize) * unisize;
		for( int i = 0 ; i < count ; i += unisize, ptr += unisize )
		{
			unsigned char h = ptr[1];
			ptr[1] = ptr[0];
			ptr[0] = h;
		}
	}
	else if( off > 0 )
		bytes.erase( bytes.begin(), bytes.begin() + off );
}

// Returns
//	bits 0-3:		encoding char size in bytes (1 = UTF-8, 2 = UTF-16 or UCS-2)
//	bit  4:			if BOM is included
//	bit  5:			if BigEndian (set) or LittleEndian (cleared)
//  bits 8-11:		BOM size in bytes
int MsxmlTreeOperations::GetEncodingAndByteOrderFromXml( std::vector<unsigned char>& sourceBytes )
{
	return sourceBytes.size() > 0 ?
		GetEncodingAndByteOrderFromXml( &sourceBytes[0], (int) sourceBytes.size() ) : 0;
}

// Returns
//	bits 0-3:		encoding char size in bytes (1 = UTF-8, 2 = UTF-16 or UCS-2)
//	bit  4:			if BOM is included
//	bit  5:			if BigEndian (set) or LittleEndian (cleared)
//  bits 8-11:		BOM size in bytes
int MsxmlTreeOperations::GetEncodingAndByteOrderFromXml( unsigned char* sourceBytes, int sourceLength )
{
	if( sourceBytes == NULL ) return 0;
	if( sourceLength < 2 ) return 0;

	if( ((sourceBytes[0] & 0xff) == 0xfe) && ((sourceBytes[1] & 0xff) == 0xff) )
		return 0x232;	// UTF-16BE with BOM

	if( ((sourceBytes[0] & 0xff) == 0xff) && ((sourceBytes[1] & 0xff) == 0xfe) )
		return 0x212;	// UTF-16LE with BOM

	if( ((sourceBytes[0] & 0xff) == 0x00) && ((sourceBytes[1] & 0xff) == 0x3c) )	// checks for "<" character
		return 0x022;	// UTF-16BE without BOM

	if( ((sourceBytes[0] & 0xff) == 0x3c) && ((sourceBytes[1] & 0xff) == 0x00) )	// checks for "<" character
		return 0x002;	// UTF-16LE without BOM

	if( sourceLength < 3 ) return 0;

	if( ((sourceBytes[0] & 0xff) == 0xef)
			&& ((sourceBytes[1] & 0xff) == 0xbb) && ((sourceBytes[2] & 0xff) == 0xbf) )
		return 0x311;	// UTF-8 with BOM

	return 0;
}

int MsxmlTreeOperations::GetUnicodeSizeFromEncodingName( const string_type& encodingIn )
{
	string_type encoding = Uppercase( encodingIn );

	if( encoding.find(_T("UTF-8")) != string_type::npos )
		return 1;

	if( encoding.find(_T("UTF-16")) != string_type::npos || encoding.find(_T("UCS-2")) != string_type::npos )
		return 2;

	return 0;
}

string_type MsxmlTreeOperations::Uppercase( const string_type& str )
{
	string_type result;
	result.reserve( str.length() );
	for (string_type::const_iterator it = str.begin(); it != str.end(); ++it)
		result.append( 1, _totupper(*it) );
	return result;
}

void MsxmlTreeOperations::SetAttribute(const MSXML2::IXMLDOMNodePtr& node, const string_type& name, const string_type& namespaceURI, const string_type& value)
{
	_bstr_t prefix = _bstr_t(_T(""));
	MSXML2::IXMLDOMElementPtr el = node;

	string_type localName = name;
	size_t i = name.find(_T(":"));
	if (i != string_type::npos)
	{
		localName = name.substr(i+1);
		prefix = _bstr_t(name.substr(0, i).c_str());
	}
	
	if (!namespaceURI.empty() && name != _T("xmlns"))
	{
		_bstr_t prefix2 = FindPrefixForNamespace(node, _bstr_t(namespaceURI.c_str()));
		if (prefix2 == _bstr_t(_T("")))
		{
			if (prefix == _bstr_t(_T("")))
				prefix = FindUnusedPrefix(node, namespaceURI);

			el->setAttribute(_bstr_t(_T("xmlns:")) + prefix, _bstr_t(namespaceURI.c_str()));
		}
		else
			prefix = prefix2;
	}

	if (prefix != _bstr_t(_T("")))
		prefix += _bstr_t(_T(":"));
		
	_bstr_t att = prefix + _bstr_t(localName.c_str());
	_bstr_t val = _bstr_t(value.c_str());

	if (att == _bstr_t(_T("xmlns")) && el->namespaceURI == val)
		return;
		
	el->setAttribute(att, val);
}


void MsxmlTreeOperations::SetAttribute(const MSXML2::IXMLDOMNodePtr& node, const string_type& localName, const string_type& namespaceURI, const string_type& valueLocalName, const string_type& valueNamespaceURI)
{
	_bstr_t prefix;
	if (!valueNamespaceURI.empty())
	{
		prefix = FindPrefixForNamespace(node, _bstr_t(valueNamespaceURI.c_str()));
		if (prefix == _bstr_t(_T("")))
		{
			prefix = FindUnusedPrefix(node, valueNamespaceURI);
			MSXML2::IXMLDOMElementPtr el = node;
			el->setAttribute(_bstr_t(_T("xmlns:")) + prefix, _bstr_t(valueNamespaceURI.c_str()));
		}
		prefix += _bstr_t(_T(":"));
	}

	SetAttribute(node, localName, namespaceURI, string_type(prefix + _bstr_t(valueLocalName.c_str())));
}


